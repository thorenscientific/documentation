<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Converter Connectivity Tutorial &#8212; System Level Documentation  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8e8a900e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/style.min.css?v=a3ba2641" />
    <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script defer="" src="../../../_static/app.umd.js?v=61e1751a"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="LTspice Example: LVDS pair" href="../../../ltspice_examples/lvds_pair/index.html" />
    <link rel="prev" title="Activity: The Wien Bridge Oscillator" href="../wien_bridge_oscillator/index.html" />
   
  
  <meta name="global_root" content="../../../../">
  <meta name="repo" content="documentation/university">
  


<style>
  body {
    
  }

  body.dark {
    
  }

  @media (prefers-color-scheme: dark) {
    body:not(.light) {
      
    }
  }
</style>
  </head><body>
  <div class="banner"></div>
  <input type="checkbox" id="input-show-toc">
  <input type="checkbox" id="input-show-localtoc">
  <input type="checkbox" id="input-show-repotoc">

  
  <div class="search-area">
    <form action="" method="get">
      <input type="text" name="q" aria-labelledby="search-documentation" value="" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" role="search" placeholder="Search"/>
      <button value="search" class="icon"></button>
      <span id="search-progress"></span>
    </form>
  </div>
  

  <header>
    <div id="left">
      <label id="show-sidebar" class="icon" for="input-show-toc" title="Show/hide index"></label>
    </div>
    <div id="right">
      <span>
        <a id="logo-org" href="https://analog.com"></a>
        <div class="vertical-divider"></div>
        <label id="show-repotoc" for="input-show-repotoc" title="Show/hide docs" tabindex="0">Docs</label>
        <a id="logo" href="../../../index.html">
          <div>System Level</div>
        </a>
      </span>
      <span class="reverse">
        <label id="show-localtoc" class="icon" for="input-show-localtoc" title="Show/hide contents"></label>
      </span>
    </div>
  </header>


  <div class="repotoc-tree overlay">
    <root>
  <a href="../../../eval/index.html">Evaluation Boards</a>
  <a href="../../../university/index.html" class="current">University Program</a>
  <a href="../../../../hdl/index.html">HDL</a>
  <a href="../../../../pyadi-iio/index.html">Hardware Python Interfaces</a>
  <a href="../../../../no-OS/index.html">no-OS</a>
  <a href="../../../../precision-converters-firmware/index.html">Precision Converters Firmware</a>
  <a href="../../../../PrecisionToolbox/index.html">Precision Toolbox</a>
  <a href="../../../../scopy/index.html">Scopy</a>
  <a href="../../../../doctools/index.html">Doctools</a>
</root>

  </div>
    <div class="localtoc">
      <div class="tocwrapper">
        <div>
          <div class="localtoc-header">On this page</div>
          <a id="scroll-up" href="#top-anchor" title="Back to top"></a>
        </div>
        <nav>
          <ul>
<li><a class="reference internal" href="#">Converter Connectivity Tutorial</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#representative-systems">Representative systems</a></li>
<li><a class="reference internal" href="#connecting-the-hardware">Connecting the Hardware</a></li>
<li><a class="reference internal" href="#burning-sd-cards">Burning SD cards</a></li>
<li><a class="reference internal" href="#adi-kuiper-linux">ADI Kuiper Linux</a></li>
<li><a class="reference internal" href="#device-tree-overlays">Device Tree Overlays</a></li>
<li><a class="reference internal" href="#hello-adxl345-adxl355-or-lm75">Hello, ADXL345, ADXL355, or LM75!</a></li>
<li><a class="reference internal" href="#python">Python</a></li>
<li><a class="reference internal" href="#pyadi-iio">PyADI-IIO</a><ul>
<li><a class="reference internal" href="#tools-for-your-toolbox-ssh-scp-vnc">Tools for your Toolbox: SSH, SCP, VNC</a></li>
</ul>
</li>
<li><a class="reference internal" href="#going-headless">Going “Headless”</a></li>
<li><a class="reference internal" href="#conclusion">Conclusion</a></li>
</ul>
</li>
</ul>

        </nav>
      </div>
    </div>

  
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
    <a id="no-logo" href="../../../index.html">
      System Level Documentation
    </a><input id="input-switch-toc" type="checkbox">
<label id="show-repotoc" for="input-switch-toc">
All content
</label>
<label id="show-toc" for="input-switch-toc">
Content on this topic
</label>
<div class="repotoc-tree">
  <root>
  <a href="../../../eval/index.html">Evaluation Boards</a>
  <a href="../../../university/index.html" class="current">University Program</a>
  <a href="../../../../hdl/index.html">HDL</a>
  <a href="../../../../pyadi-iio/index.html">Hardware Python Interfaces</a>
  <a href="../../../../no-OS/index.html">no-OS</a>
  <a href="../../../../precision-converters-firmware/index.html">Precision Converters Firmware</a>
  <a href="../../../../PrecisionToolbox/index.html">Precision Toolbox</a>
  <a href="../../../../scopy/index.html">Scopy</a>
  <a href="../../../../doctools/index.html">Doctools</a>
</root>

</div>
<div class="toc-tree">
  <html>
  <body><p class="caption" role="heading"><span class="caption-text">Active Learning</span></p>
<ul class="current">
<li class="toctree-l1 current"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-1" id="toctree-collapse-1" checked=""/><div class="collapse"><a class="reference internal" href="../index.html">Exercises</a><label for="toctree-collapse-1"><div class="icon"></div></label></div><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../wien_bridge_oscillator/index.html">Activity: The Wien Bridge Oscillator</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Converter Connectivity Tutorial</a></li>
</ul>
</li>
</ul>
</body>
</html>

</div>
        </div>
      </div>

  <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper" id="top-anchor">
          <div class="body" role="main">
            
  <section id="converter-connectivity-tutorial">
<h1>Converter Connectivity Tutorial<a class="headerlink" href="#converter-connectivity-tutorial" title="Link to this heading">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>You don’t have to be a software engineer in order to leverage device drivers and example code as you are evaluating and prototyping with Analog Devices’ data converters and converter-like products. Selection of an ADC, DAC, or sensor often starts by finding something that meets performance requirements (obviously). This may be followed with some experimentation with the device’s evaluation board and accompanying software, but at some point you need to “take the next step”. This “next step” could be any one of a wide array of things - wiring the eval board to a prototype of a larger system, deeper characterization using your own benchtop test equipment, or any one of a plethora of random requirements. This tutorial will arm you with a number of tools to this end.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Update:</strong>
The first version of this tutorial was published in early 2020, after test driving the setup with a few select field engineers. A lot has happened since then:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://wiki.analog.com/resources/tools-software/linux-software/kuiper-linux">ADI Kuiper Linux</a> has matured considerably, with broad support for ADI devices and popular processor and FPGA development platforms.</p></li>
<li><p>The very popular <a class="icon adi reference external" href="https://www.analog.com/eval-adxl355-pmdz">ADXL355 Pmod</a> would have been used initially, but the Linux driver had not been upstreamed yet. It has since been released, and is being added as an option for this tutorial. (The original ADXL345 / Digilent Pmod-ACL is still included.)</p></li>
<li><p>LibIIO now supports HWMON devices (if these terms aren’t familiar, you’ll learn about them soon), enabling the use of the absolute <strong>best</strong> device to start learning about embedded Linux systems: the LM75 temperature sensor. It is an industry standard with several manufacturers, including the <a class="icon adi reference external" href="https://www.analog.com/LM75">Maxim LM75</a> and ADI’s variant, <a class="icon adi reference external" href="https://www.analog.com/ADT75">ADT75</a></p></li>
</ul>
<p>So while it’s genereally not a good idea to have too many options in a basic tutorial, we felt that having a couple was appropriate here, incuding one that is very low cost (the LM75).</p>
</div>
<p>Analog Devices provides an assortment of evaluation boards and reference designs for converters of various channel counts, bandwidths, and other functionality, whose drivers fit into the Industrial Input Output (IIO) framework. This framework facilitates robust data transfer to or from the converter into “userspace”, where the user program could be a MATLAB script for device characterization, a Python script that talks to benchtop signal generators and spectrum analyzers via GPIB in addition to the ADI part under test, or a C program embedded in the end product. Most of these involve fairly costly reference design hardware installed on even more costly FPGA platform boards, which, to extract maximum performance, require test equipment exceeding the cost of a luxury car. So the question arises - what is the simplest, lowest cost system that captures the important aspects of these larger systems? $50 total for a Raspberry Pi, SD card, and an LM75 temperature sensor (or ADXL355 or ADXL345 board) sounds like a pretty reasonable deal. The only test equipment required is:</p>
<ul class="simple">
<li><p>You (your finger to warm up the LM75, or shake the ADXL3x5)</p></li>
<li><p>The Earth (to provide a precise, low-noise, -9.8m/s<sup>2</sup> acceleration)</p></li>
</ul>
<figure class="align-center">
<a class="reference internal image-reference" href="../../../_images/simple_iio_hardware.png"><img alt="../../../_images/simple_iio_hardware.png" src="../../../_images/simple_iio_hardware.png" style="width: 400px;" />
</a>
</figure>
<p><strong>Figure 1. Ultra-simple IIO-based system</strong></p>
<div class="line-block">
<div class="line"><strong>A Note on Security:</strong> The Raspberry Pi is a fantastic tool, but it can represent a network security gap if used improperly. Our Raspberry Pi will start out configured in a fairly open state - a simple root password, SSH login enabled. This isn’t an issue if the Raspberry Pi does not have internet access or is behind a firewall, but if you are going to connect to your network, it’s a good idea to change the password to something secure. Refer to this article on Raspberry Pi Security:</div>
<div class="line"><a class="reference external" href="https://www.raspberrypi.org/documentation/configuration/security.md">Securing your Raspberry Pi</a></div>
</div>
<p><strong>A Note on the Tutorial:</strong> This tutorial is hands-on, and attempts to be clear and consistent. But there are often several “right” ways of doing a step - choice of editor to modify files on an SD card, using a Windows, Mac, or Linux machine, etc. When in doubt: <strong>Double-check your wiring</strong>, and just try stuff. Worst case, you’ll need to re-burn your SD card to get back to the starting point.</p>
</section>
<section id="representative-systems">
<h2>Representative systems<a class="headerlink" href="#representative-systems" title="Link to this heading">¶</a></h2>
<p>We are intentionally starting with an extremely simple example. But once you understand how to communicate with an LM74, ADXL345, or ADXL355, you’re well over the intitial learning curve to understanding much more complicated systems. The <a class="reference external" href="/university/tools/pluto">ADALM-Pluto</a> is a great example - it contains an AD9363 RF Agile Transcieiver, Zynq SoC FPGA, Memory, USB interface, and much more. Even the simplified block diagram is pretty daunting:</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../../_images/pluto_medium_block_diagram.png"><img alt="../../../_images/pluto_medium_block_diagram.png" src="../../../_images/pluto_medium_block_diagram.png" style="width: 200px;" />
</a>
</figure>
<p><strong>Figure 2. Pluto Simplified Block Diagram</strong></p>
<p>If the Pluto wasn’t scary enough, the <a class="icon adi reference external" href="https://www.analog.com/cn0566">Phased Array (Phaser) Development Platform</a> might be a step in that direction. It incorporates two <a class="icon adi reference external" href="https://www.analog.com/adiADAR1000">ADAR1000</a> beamformers, an <a class="icon adi reference external" href="https://www.analog.com/AF4159">ADF4159</a> Fast Waveform Generating, 13 GHz, Fractional-N Frequency Synthesizer and uses the Pluto as its IF digitizer. It’s also got a <a class="icon adi reference external" href="https://www.analog.com/AD7291">AD7291</a> 8-Channel, I2C, 12-Bit SAR ADC with Temperature Sensor for basic monitoring; a simple device by comparison, but it’s got its own device driver, and is adjacent the more complex devices both physically and in software.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../../_images/2-23-2023_4-37-00_pm.png"><img alt="../../../_images/2-23-2023_4-37-00_pm.png" src="../../../_images/2-23-2023_4-37-00_pm.png" style="width: 600px;" />
</a>
</figure>
<p><strong>Figure 3. Phaser System Overview</strong></p>
<p>But - all of the phaser’s devices work together, and by the time you finish this tutorial you’ll be able to chip away at understanding how the individual devices work, and eventually, how they whole system works.</p>
</section>
<section id="connecting-the-hardware">
<h2>Connecting the Hardware<a class="headerlink" href="#connecting-the-hardware" title="Link to this heading">¶</a></h2>
<div class="line-block">
<div class="line">Before we dig too deep into software stuff, let’s prepare the hardware. There are lots of ways to connect boards together, custom adapters, Raspberry Pi prototyping hats, etc. The <a class="icon adi reference external" href="https://www.analog.com/PMD-RPI-INTZ">PMD-RPI-INTZ</a> is an interposer that simplifies connecting I2C and SPI Pmod boards, QuikEval compatible eval boards, and Power System Managemement (PSM) eval boards to a Raspberry Pi. Figure 4 shows the <a class="reference external" href="https://store.digilentinc.com/pmod-acl-3-axis-accelerometer/">ADXL345 Pmod</a> (available directly from Digilent and from various distributors) mounted to the PMD-RPI-INTZ board. Note that the Pmod must be installed on P1, which uses SPI CS0 and has the interrupt pin connected to GPIO 19.</div>
</div>
<figure class="align-center">
<a class="reference internal image-reference" href="university/active_learning/converter_connectivity_tutorial/adxl354_pmd-rpi-intz.jpg"><img alt="university/active_learning/converter_connectivity_tutorial/adxl354_pmd-rpi-intz.jpg" src="university/active_learning/converter_connectivity_tutorial/adxl354_pmd-rpi-intz.jpg" style="width: 400px;" />
</a>
</figure>
<p><strong>Figure 4. ADXL345 Pmod Mounted to PMD-RPI-INTZ Interposer</strong></p>
<p>Another option that generally applies to eval boards with test points on the digital signals is to use discrete jumper wires. Five inch jumpers from Schmartboard: <a class="reference external" href="https://schmartboard.com/wire-jumpers/female-jumpers/5-inch/">Schmartboard Jumpers</a> are very convenient.</p>
<p>If you are using Jumpers, use Figure 1 as a visual aid and make the connections shown in Figure 5. The accelerometer board is a Digilent model Pmod:ACL, It is essentially a breakout board for the ADXL345.</p>
<div class="line-block">
<div class="line">In theory, any Raspberry Pi should work, although it is probably best to use a modern model with a 40-pin expansion header. (The model shown in Figure 1 is a model 3B, version 1.2.)</div>
<div class="line">Note that there are TWO SPI ports - SPI0 and SPI1. We will be using SPI0 (Pins 8, 19, 21, 23)</div>
</div>
<figure class="align-center">
<a class="reference internal image-reference" href="../../../_images/rpi_adxl345_connections.png"><img alt="../../../_images/rpi_adxl345_connections.png" src="../../../_images/rpi_adxl345_connections.png" style="width: 400px;" />
</a>
</figure>
<p><strong>Figure 5. RPi-Pmod connections</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>To Do:</strong>
- Add detailed pictures of ADXL355 Pmod and options for LM75 and ADT75.
In the meantime - it’s straightforward:</p>
<ul class="simple">
<li><p>The ADXL355 Pmod plugs into the same P1 location on the PMD-RPI-INTZ</p></li>
<li><p>The Digilent <a class="reference external" href="https://digilent.com/shop/pmod-tmp3-digital-temperature-sensor/">Pmod TMP3</a> uses the compatible Microchip TCN75A temperature sensor. It’s not the most convenient; it’s not truly Pmod compatible because the header is mounted vertically, the easiest way to connect it to the Pi is with Schmartboard jumpers.</p></li>
<li><p>The Analog Devices LM75 and ADT75 don’t have convenient eval boards so the best option is to solder them to breakout boards</p></li>
<li><p>There are several “maker style” LM75 breakout boards offered by your favorite online vendors that should work fine.</p></li>
</ul>
</div>
</section>
<section id="burning-sd-cards">
<h2>Burning SD cards<a class="headerlink" href="#burning-sd-cards" title="Link to this heading">¶</a></h2>
<div class="line-block">
<div class="line">In order to boot the Raspberry Pi, you will need to obtain an SD card “image”, and write (or “burn”) it to a card. We’ll talk about where to get the correct image shortly. This is a fairly common step in bringing up embedded computers - Raspberry Pi, BeagleBone, Zedboard, Arrow SoCkit, or any machine that boots from an SD card. There are lots of ways to burn images, but the most straightforward way is to use the standard Raspberry Pi Imager, available here:</div>
<div class="line"><a class="reference external" href="https://www.raspberrypi.com/software/">Raspberry Pi OS (including Raspbery Pi Imager</a></div>
</div>
<p>There are instructions for Windows, Mac, and Linux. The imager also works on machines that encrypt data being written to external drives since it’s writing “raw” data. HOWEVER - beware encryption software when editing configuration files! (More on that later…)</p>
<figure class="align-center">
<a class="reference internal image-reference" href="university/active_learning/converter_connectivity_tutorial/raspberry_pi_imager.png"><img alt="university/active_learning/converter_connectivity_tutorial/raspberry_pi_imager.png" src="university/active_learning/converter_connectivity_tutorial/raspberry_pi_imager.png" style="width: 600px;" />
</a>
</figure>
<p><strong>Figure 6. Raspberry Pi Imager Screenshot</strong></p>
<p>A new SD card is usually preformatted as a single EXFAT partition, usable by all operating system. But after burning an image to the card, it will show up as several partitions, not all of which are visible to all operating systems. So if you burn a card in Windows, and a popup appears saying “This drive needs to be formatted, would you like to format now?”, the answer is <strong>NO!</strong> Figure 7 shows the SD card partitions before and after burning the image. Attempting to read the partition map in Windows (under Administrative Tools, Disk Management) will show the ext4 partition as “unknown”</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../../_images/sd_card_partitions.png"><img alt="../../../_images/sd_card_partitions.png" src="../../../_images/sd_card_partitions.png" style="width: 600px;" />
</a>
</figure>
<p><strong>Figure 7. SD card partitions before and after “burning”</strong></p>
<p>Helpful Hint: It may happen that an SD card becomes corrupted somehow. This can sometimes be fixed in Windows by opening storage manager in Administrative tools, then removing all partitions, and reformatting as EXFAT (a similar procedure can be followed using fdisk in Linux.) But computers are smart - sometimes too smart - and there are cases where these tools fail to repartition a drive. However - digital cameras are not as smart, and using a digital camera’s (such as a Nikon D90) SD card formatting feature will often resurrect a “bricked” card.</p>
</section>
<section id="adi-kuiper-linux">
<h2>ADI Kuiper Linux<a class="headerlink" href="#adi-kuiper-linux" title="Link to this heading">¶</a></h2>
<p>What is “ADI Kuiper Linux”? Here’s a little glossary:</p>
<ul class="simple">
<li><p>Debian = A Popular Linux Distribution</p></li>
<li><p>Raspberry Pi OS = Debian customized for Raspberry Pi</p></li>
<li><p>ADI Kuiper Linux = ADI’s Raspberry Pi OS variant with extra goodies:</p>
<ul>
<li><p>All drivers for ADI, LTC parts that make sense enabled</p></li>
<li><p>Boot files for FPGA-based reference designs and evaluation boards targetting a number of popular FPGA platforms, including:</p>
<ul>
<li><p>Data acquisition and transciever boards (FMCOMMSx, FMCDAQx, etc.)</p></li>
<li><p>ZedBoard, Digilent Cora Z7, ZCU102, Intel DE10-Nano, Arria 10 SoC dev kit</p></li>
</ul>
</li>
<li><p>LibIIO, IIO Oscilloscope, other ADI programs and utilities.</p></li>
<li><p>iiod runs at startup</p></li>
<li><p>GNURadio</p></li>
</ul>
</li>
</ul>
<div class="line-block">
<div class="line">More information on Raspberry Pi OS can be found at <a class="reference external" href="https://www.raspberrypi.com/software/">Raspberry Pi OS</a>. Raspberry Pi OS includes lots of fun stuff - Minecraft, an office suite, web browser, sound processing labs, other games, etc. We won’t cover any of that, but do explore on your own!</div>
<div class="line">(More information on the Kuiper Belt can be found at <a class="reference external" href="https://en.wikipedia.org/wiki/Kuiper_belt">Kuiper_belt</a>)</div>
<div class="line">The SD card image is available here:</div>
<div class="line"><a class="reference external" href="/resources/tools-software/linux-software/kuiper-linux">Analog Devices Kuiper Linux</a></div>
</div>
<p>Download the compressed zip file, and extract the .img file. (tar.gz files can be extrtracted using 7zip in Windows.) Follow the procedure for burning SD cards above, using a 16GB (or larger), high-quality, Class 10 or faster SD card.</p>
<p>At this point, you should be able to:</p>
<ol class="arabic simple">
<li><p>insert the card into the Raspberry Pi</p></li>
<li><p>Connect an HDMI monitor</p></li>
<li><p>Connect a USB keyboard and mouse</p></li>
<li><p>Supply power via a micro-USB cable and old phone charger.</p></li>
</ol>
<p>Note: <em>It is possible to use the Raspberry Pi without a local keyboard, mouse, monitor - see the “Going Headless” section below.</em></p>
<p>If all goes well, you should see a desktop. From the start menu, click Other -&gt; IIO Oscilloscope (or open a terminal and run IIO Oscilloscope):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>analog@analog:~$ sudo osc
</pre></div>
</div>
<p>(Enter the root password, “analog” by default unless you followed the advice above to change it.) You should then see IIO oscilloscope running as shown in Figure 8! Also note that IIO Oscilloscope will run without root privileges, but all devices will be read-only. For example, you won’t be able to change the ADXL3x5’s sampling frequency, or LM75’s over/under temperature thresholds.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../../_images/rpi_desktop.png"><img alt="../../../_images/rpi_desktop.png" src="../../../_images/rpi_desktop.png" style="width: 600px;" />
</a>
</figure>
<p><strong>Figure 8. Raspberry Pi w/ ADI Kuiper Linux desktop</strong></p>
<p>But… if you look at the IIO oscilloscope panels, where’s the ADXL3x5 or LM75? Well, the Linux kernel does a bunch of stuff during boot, controlled by various configuration files (remember autoexec.bat and config.sys on old DOS systems?, Yup, the authore has suppressed that memory, too.) One of them, /boot/config.txt, is how you tell Linux about what hardware is connected, and the default is NOT the ADXL345… so let’s fix that.</p>
</section>
<section id="device-tree-overlays">
<h2>Device Tree Overlays<a class="headerlink" href="#device-tree-overlays" title="Link to this heading">¶</a></h2>
<p>When we first powered up the Raspberry Pi and ran IIO Oscilloscope it didn’t find anything. While we do have our ADXL3x5/LM75 physically connected to the board, Linux doesn’t know about it yet because UNlike USB, PCI, SCSI, Firewire, HDMI, etc, SPI and I2C devices do not support enumeration. How do we tell the Linux kernel what we’ve connected to the expansion header? The answer is the “Device Tree Overlay”.</p>
<p>While you won’t have to do anything more than editing a couple of files in this tutorial, it helps to understand a bit about what is going on under the surface. A “Device Tree” contains information about a system’s hardware - what peripherals exist (like displays, memory, USB, Ethernet controllers, GPIO pins, etc.) A “Device Tree Overlay” contains information about additional connected hardware, like our ADXL3x5/LM75. Figure 9 shows a screenshot of the ADXL345’s overlay source. It shows that the ADXL345 is connected to the SPI port, using the first CS signal (CS0), the maximum SPI clock frequency is 1MHz, and the interrupt signal is connected to Pin 19 (as shown in the connection diagram above.)</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../../_images/device_tree.png"><img alt="../../../_images/device_tree.png" src="../../../_images/device_tree.png" style="width: 600px;" />
</a>
</figure>
<p><strong>Figure 9. Partial ADXL345 overlay source (dts)</strong></p>
<p>The device tree source is then compiled into a “flattened” device tree that the Linux kernel reads directly. While this process is fairly straightforward, it’s beyond the scope of this tutorial. Furthermore, the device tree overlay for this tutorial is already included on the SD card, along with several other overlays for other hardware configurations. (Note that the device tree overlay is specific to a particular device AND how it is connected to the Raspberry Pi. Any changes to the connections - SPI CS line, interrrupt line, etc. will require a corresponding modification to the overlay.)</p>
<p>For reference, here are the overlay source files for the three devices in this tutorial. These are in the Linux rpi-5.15.y branch, used for Kuiper Linux 2022_r2 release:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/analogdevicesinc/linux/blob/rpi-5.15.y/arch/arm/boot/dts/overlays/rpi-lm75-overlay.dts">LM75 Device Tree Overlay</a></p></li>
<li><p><a class="reference external" href="https://github.com/analogdevicesinc/linux/blob/rpi-5.15.y/arch/arm/boot/dts/overlays/rpi-adxl345-overlay.dts">ADXL345 Device Tree Overlay</a></p></li>
<li><p><a class="reference external" href="https://github.com/analogdevicesinc/linux/blob/rpi-5.15.y/arch/arm/boot/dts/overlays/rpi-adxl355-overlay.dts">ADXL355 Device Tree Overlay</a></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For more gory details on device trees, a great resource is <a class="reference external" href="https://elinux.org/images/f/f9/Petazzoni-device-tree-dummies_0.pdf">Device Tree for Dummies</a> by Thomas Petazzoni.</p>
</div>
<p>So keeping with the spirit of doing while we’re learning, let’s configure the overlay for this experiment. The device tree overlay is specified in the config.txt file, which lives in the BOOT partition on the SD card. There are several ways to edit this file - Since the BOOT partition is a FAT filesystem, you can use any text editor on any operating system; Notepad on Windows, Kedit on Linux, etc. Or… if your Raspberry Pi is booted up, you can edit directly on the Pi! Just open a command prompt, and type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>analog@analog:~$ sudo mousepad /boot/config.txt
</pre></div>
</div>
<p>which will bring up the file in the Mousepad editor. Scroll down until you find the line that begins with “dtoverlay”, and, whatever it happens to be, change it to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dtoverlay</span><span class="o">=</span><span class="n">rpi</span><span class="o">-</span><span class="n">adxl345</span>
<span class="c1"># dtoverlay=rpi-adxl345</span>
<span class="c1"># dtoverlay=rpi-lm75,addr=0x48</span>
<span class="n">dtparam</span><span class="o">=</span><span class="n">act_led_trigger</span><span class="o">=</span><span class="n">heartbeat</span>
<span class="n">dtoverlay</span><span class="o">=</span><span class="n">gpio</span><span class="o">-</span><span class="n">shutdown</span><span class="p">,</span><span class="n">gpio_pin</span><span class="o">=</span><span class="mi">21</span><span class="p">,</span><span class="n">active_low</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">gpiopull</span><span class="o">=</span><span class="n">up</span>
</pre></div>
</div>
<figure class="align-center">
<a class="reference internal image-reference" href="../../../_images/edit_config.png"><img alt="../../../_images/edit_config.png" src="../../../_images/edit_config.png" style="width: 600px;" />
</a>
</figure>
<p><strong>Figure 10. Editing config.txt directly on Raspberry Pi</strong></p>
<p>Notice the two commented lines beginning with <strong>#</strong>. As you might expect, you should UN-comment the appropriate line for the device you have connected.
Also notice that there are a couple of additional lines - there are lots of useful optional parameters that can be set in the config.txt file, here we’re setting the onboard LED to the “heartbeat” function, this makes it easy to see if the board is running or shut down, even if you don’t have a display connected. The other line turns GPIO21 into a hardware shutdown function, also very useful if you are operating the board without a display.
| If you want to make it easy to revert back to some other overlay, comment out the original line with a pound sign / hashtag:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#dtoverlay=rpi-something-other-than-adxl345</span>
<span class="n">dtoverlay</span><span class="o">=</span><span class="n">rpi</span><span class="o">-</span><span class="n">adxl345</span>
</pre></div>
</div>
<p>One last thing worth noting - the default video resolution is 1920x1080. If this causes problems with your monitor, hanging hdmi_group, mode to 2, 58:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">hdmi_group</span><span class="o">=</span><span class="mi">2</span>
<span class="n">hdmi_mode</span><span class="o">=</span><span class="mi">58</span>
</pre></div>
</div>
<p>will set the screen resolution to 1680x1050. Information on other video modes is available here:</p>
<p><a class="reference external" href="https://www.raspberrypi.org/documentation/configuration/config-txt/video.md">Raspberry Pi Video Modes</a></p>
<p>However you edit the file, save, close, cross your fingers, and… reboot! You can do this from the start menu, or from a terminal type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sudo</span> <span class="n">reboot</span>
</pre></div>
</div>
<p>To shut down at the end of the day, type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sudo</span> <span class="n">shutdown</span> <span class="o">-</span><span class="n">h</span> <span class="n">now</span>
</pre></div>
</div>
</section>
<section id="hello-adxl345-adxl355-or-lm75">
<h2>Hello, ADXL345, ADXL355, or LM75!<a class="headerlink" href="#hello-adxl345-adxl355-or-lm75" title="Link to this heading">¶</a></h2>
<p>If all went well, Linux should have booted, found the ADXL3x5 or LM75, and loaded its driver. Run IIO Oscilloscope again. locate the DMM screen, check the ADXL345, select all channels, and click the triangular “play” button. You should see acceleration values displayed as shown in Figure 11.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../../_images/iio_scope_adxl345.png"><img alt="../../../_images/iio_scope_adxl345.png" src="../../../_images/iio_scope_adxl345.png" style="width: 600px;" />
</a>
</figure>
<p><strong>Figure 11. IIO Oscilloscope showing ADXL345 channels</strong></p>
<p>IIO Oscilloscope is a great tool for establishing signs of life, but really isn’t intended for much more, so let’s start digging deeper into how to communicate with the ADXL345 programmatically. Close out of IIO Oscilloscope, open a terminal and enter:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>analog@analog:~$ iio_info
</pre></div>
</div>
<p>You should see the screen filled with information about the ADXL345 - sample rates, “raw” values, scale values, etc. This means that you’re ready to start writing programs to do useful stuff with the ADXL345… on the Raspberry Pi itself. But before we go there, let’s introduce one more extraordinarily powerful feature of the IIO framework - the ability to communicate remotely over a network connection. This ability is made up of two components: an IIOD server running on the Raspberry Pi, and LibIIO running on the remote machine. LibIIO is cross-platform, so client applications can be written on Windows / Mac / Linux.</p>
<p>Let’s take a peek at the IIOD server. In the Raspberry Pi terminal, enter:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>analog@analog:~$ ps aux | grep iiod
</pre></div>
</div>
<p>Which means “list all processes from all users, but only display ones that include the text “iiod””. You should see a process running as shown in Figure 12 below. (Note that this is the login screen for an ADALM2000 - it’s all the same.)</p>
<p>And the red line relates this process back to the handy little diagram from <a class="reference external" href="/resources/tools-software/linux-software/libiio/">What is Libiio?</a> (We will be recycling that diagram - a lot.)</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../../_images/iiod_process_screenshot.png"><img alt="../../../_images/iiod_process_screenshot.png" src="../../../_images/iiod_process_screenshot.png" style="width: 600px;" />
</a>
</figure>
<p><strong>Figure 12. IIOD process</strong></p>
<p>The other piece is libiio on the remote host. LibIIO can be obtained from:</p>
<p><a class="reference external" href="https://github.com/analogdevicesinc/libiio/releases">LibIIO Github Repo</a></p>
<p>Download and install the appropriate latest version for your remote host (For example, libiio-0.24.gc4498c2-Windows-setup.exe for Windows) Once this is done, open a command prompt, and enter:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iio_info</span> <span class="o">-</span><span class="n">u</span> <span class="n">ip</span><span class="p">:</span><span class="n">analog</span><span class="o">.</span><span class="n">local</span>
</pre></div>
</div>
<p>(Where the IP address may be different, depending on how you’ve connected.) If all goes well, you should see lots of information associated with the ADXL345… that is connected to your Raspberry Pi… but from your Windows / Linux / Mac machine! <em>(How cool is that?)</em></p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../../_images/iio_info_local_remote.png"><img alt="../../../_images/iio_info_local_remote.png" src="../../../_images/iio_info_local_remote.png" style="width: 600px;" />
</a>
</figure>
<p><strong>Figure 13. iio_info run locally and remotely</strong></p>
<p>NOW you’ve got all the pieces for some fun hacking - you can write software that runs directly on the Raspberry Pi and talks to the ADXL345 (which… is conceptually similar to writing software that runs on a Xilinx SoC board and grabs data from an attached high-speed ADC) AND, you can write software on a remote host - useful if you want a larger application that is more appropriate to run on the host, or if you want to grab large amounts of data for analysis.</p>
<p>LibIIO is written natively in C, but there are bindings for MATLAB, C#, and Python. Let’s use Python…</p>
</section>
<section id="python">
<h2>Python<a class="headerlink" href="#python" title="Link to this heading">¶</a></h2>
<p>Any language that can call a shared library can communicate with libiio. But Python is attractive for getting started for several reasons:</p>
<div class="line-block">
<div class="line">It’s FREE It’s tremendously popular It’s got tons of number crunching libraries It’s got tons of libraries for communicating with hardware (It’s also really really fun!) And - it’s easy to learn. If you’ve never touched Python before, there are lots of free resources, including this 4-hour course on YouTube from freeCodeCamp.org:</div>
</div>
<div class="iframe-video"><iframe src="https://www.youtube-nocookie.com/embed/rfscVS0vtbw"></iframe></div><p>And this very nice interactive tutorial:
<a class="reference external" href="https://www.learnpython.org/">Learn Python</a>
in which code snippets run in the browser (no need to intall Python.)
If you prefer paper, <a class="reference external" href="https://nostarch.com/python-kids-2nd-edition">Python for Kids by Jason R. Briggs</a> is a well written books for kids of all ages. (And <a class="reference external" href="https://nostarch.com/programwithminecraft">Learn to Program with Minecraft: Transform Your World with the Power of Python</a> by Craig Richardson is a pretty nice introduction to the idea of communicating over a network connection; the Minecraft world is a process that communicates over network ports.)</p>
<p>There are several choices of Python installations, and which one to use is largely a matter of preference. You can install from scratch from <a class="reference external" href="https://www.python.org/">Python.org</a>, or a more full featured distribution such as Anaconda, PyCharm, or VS Code. And <strong>Python is pre-installed on ADI Kuiper Linux</strong>, as is the Thonny IDE. Thonny is basic as far as IDEs go, but it provides breakpoints, variable watches, and is perfectly adequate for simple to intermediate development.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On Python Versions - We’re using Python 3 (3.9.2 in Kuiper 2022_r2 to be specific.) So if you’re installing on your remote host, make sure to get a recent version of Python 3. Previous Kuiper Linux releases had multiple Python versions installed, defaulting to Python 2.x. The current Kuiper Linux defaults to Python 3 so this is no longer an issue, but for historical curiosity the procedure for setting the default to Python 3 is to run the following commands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>analog@analog:~$ sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1
analog@analog:~$ sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.7 2
</pre></div>
</div>
<p>(This only needs to be done once.)</p>
</div>
</section>
<section id="pyadi-iio">
<h2>PyADI-IIO<a class="headerlink" href="#pyadi-iio" title="Link to this heading">¶</a></h2>
<p>PyADI-IIO (pronounced “Py-odi” <a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> is like <a class="reference external" href="https://en.wikipedia.org/wiki/peyote">peyote</a>, but with a Py) is a python abstraction module for ADI hardware with IIO drivers to make them easier to use. Pyadi-iio can be installed through pip, and is pre-installed on ADI Kuiper Linux, but if you’re reading this you’ll probably want to be hacking around a bit so go to <a class="reference external" href="https://github.com/analogdevicesinc/pyadi-iio">PyADI-IIO Github Repo</a> and follow the “installing from source” instructions. And note that this can be done on your remote Windows / Mac / Linux host AND… on the Raspberry Pi itself! Git is already installed on ADI Kuiper Linux, but may need to be installed on a Windows host. (You can also download the repository as a zip, but cloning will make it easier to update.) Let’s install pyadi-iio.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>analog@analog:~ $ git clone https://github.com/analogdevicesinc/pyadi-iio.git
analog@analog:~ $ cd pyadi-iio
analog@analog:~/pyadi-iio $ sudo pip install .
</pre></div>
</div>
<p>Note: This requires that your Raspberry Pi be able to access the internet. If you’ve followed the “headless” instructions below, this may not be the case. However - if you have access to a wireless network and your Raspberry Pi has an Ethernet adapter, you can connect in this way. Just click the WiFi icon and log on as you would on any other machine, supplying a password if necessary</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../../_images/rpi_wifi_login.png"><img alt="../../../_images/rpi_wifi_login.png" src="../../../_images/rpi_wifi_login.png" style="width: 600px;" />
</a>
</figure>
<p><strong>Figure 14. WiFi logon</strong></p>
<p>Now it’s (almost) trivial to grab data from the ADXL345 used in this tutorial, as well as more complicated hardware. With pyadi-iio installed, you should be able to run the ADXL345 example.</p>
<div class="line-block">
<div class="line">&lt;WRAP todo&gt; <strong>To Do:</strong></div>
<div class="line">Update ADXL345 pyadi-iio example.</div>
<div class="line">As of Feb. 2024, the ADXL345 example has a hardcoded ip address. Most newer examples allow the context to be passed via command line argument, but in the meantime change line 10 from:</div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">myacc</span> <span class="o">=</span> <span class="n">adi</span><span class="o">.</span><span class="n">adxl345</span><span class="p">(</span><span class="n">uri</span><span class="o">=</span><span class="s2">&quot;ip:192.168.1.232&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">myacc</span> <span class="o">=</span> <span class="n">adi</span><span class="o">.</span><span class="n">adxl345</span><span class="p">(</span><span class="n">uri</span><span class="o">=</span><span class="s2">&quot;ip:localhost&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Enter the following commands, making sure you’re in the pyadi-iio root directory:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>analog@analog:~/pyadi-iio $ cd examples
analog@analog:~/pyadi-iio/examples $ python adxl345_example.py
</pre></div>
</div>
<p>The example program takes a few acceleration readings, shows how to set the sample rate, and shows how to convert values to SI units.</p>
<p>If you’re running the example on the remote host, you should be able to talk to the Pi by using the context “ip:analog.local”, the address noted for the “headless” configuration below. If your Raspberry Pi’s address is different (supplied by DHCP, for example), change it accordingly. The example will also run locally, with the same IP address! But as soon as the IP address changes, the example won’t work any more. Since we’re running locally, you can set the IP address to the local loopback address:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">myacc</span> <span class="o">=</span> <span class="n">adi</span><span class="o">.</span><span class="n">adxl345</span><span class="p">(</span><span class="n">uri</span><span class="o">=</span><span class="s2">&quot;ip:localhost&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>But since we’re running locally, why bother talking through IIOD? Setting the context to local takes care of that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">myacc</span> <span class="o">=</span> <span class="n">adi</span><span class="o">.</span><span class="n">adxl345</span><span class="p">(</span><span class="n">uri</span><span class="o">=</span><span class="s2">&quot;local:&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>But there’s one subtlety… run Python as root ( sudo python adxl345_example.py ). The reason is that IIOD runs with root privileges and can read / write to devices. The example script will be able to read just fine, but writing even something as mundane as the sample rate requires root privileges.</p>
<p>The example script should run just fine on the Raspberry Pi itself, and on the remote host. Try writing a program to read out a hundred samples from each channel (X,Y,Z) and store to a file, or if you’re really adventurous, display the 3-axis acceleration as an arrow in a graphical screen.</p>
<p>The ADXL355 and LM75 examples allow the IIO context to be passed as a command line argument. From the command line, run the following for the ADXL355:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>analog@analog:~/pyadi-iio/examples $ python adxl355_example.py ip:localhost
</pre></div>
</div>
<p>And this for the LM75:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>analog@analog:~/pyadi-iio/examples $ python lm75_example.py ip:localhost
</pre></div>
</div>
<section id="tools-for-your-toolbox-ssh-scp-vnc">
<h3>Tools for your Toolbox: SSH, SCP, VNC<a class="headerlink" href="#tools-for-your-toolbox-ssh-scp-vnc" title="Link to this heading">¶</a></h3>
<p>Putty and TeraTerm are popular (and free) SSH clients that let you log into a console on your Raspberry Pi (or other remote client). They are available at <a class="reference external" href="https://www.putty.org/">PuTTY Homepage</a> and <a class="reference external" href="https://ttssh2.osdn.jp/index.html.en">TeraTerm Homepage</a> , respectively. Try both, which one is better is largely a matter of preference.</p>
<p>On Mac and Linux machines, you can simply log in via ssh from the command line.</p>
<p>WinSCP is a handy tool that lets you copy files between a Windows machine and your Raspberry Pi, for example, let’s say you collect some data on your Pi using a Python script, and want to get it over to your Windows machine. It is available from <a class="reference external" href="https://winscp.net/eng/index.php">WinSCP Homepage</a>.</p>
<p>As with SSH, Mac and Linux machines include SCP already.</p>
<p>VNC is a remote desktop application, and Kuiper Linux runs a VNC server by default. There are several clients available; RealVNC works well and is available at <a class="reference external" href="https://www.realvnc.com/en/connect/download/viewer/">RealVNC Viewer</a> A screenshot of VNC logged into the Raspberry Pi is shown in Figure 15.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../../_images/rpi_vnc.png"><img alt="../../../_images/rpi_vnc.png" src="../../../_images/rpi_vnc.png" style="width: 600px;" />
</a>
</figure>
<p><strong>Figure 15. VNC desktop</strong></p>
</section>
</section>
<section id="going-headless">
<h2>Going “Headless”<a class="headerlink" href="#going-headless" title="Link to this heading">¶</a></h2>
<div class="line-block">
<div class="line">(Ignore if you’re using a monitor / keyboard / mouse) If it happens that you don’t have a spare monitor / keyboard / mouse, or it’s just inconvenient, you can operate the Raspberry Pi with only a network connection. By default, the ADI Kuiper Linux network hostname is <strong>analog</strong>, and the machine can be accessed as <strong>analog.local</strong>.</div>
<div class="line">The Raspberry Pi can also be accessed directly by its IP address. If your network has a DHCP server, and you can find the IP address that it assigned to the Raspberry Pi, you’re all set. But a very robust way is to set the Raspberry Pi’s address manually, and do the same to one network adapter on the host. To set the Raspberry Pi’s address, open the boot partition on a host machine (once again… BEWARE ENCRYPTION!), and note that this host machine could be the Raspberry Pi itself, with a montior / keyboard / mouse attached. Open the file “cmdline.txt” and add the following to the end:</div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ip</span><span class="o">=</span><span class="mf">192.168.1.232</span><span class="p">::</span><span class="mf">192.168.1.1</span><span class="p">:</span><span class="mf">255.255.255.0</span><span class="p">:</span><span class="n">rpi</span><span class="p">:</span><span class="n">eth0</span><span class="p">:</span><span class="n">off</span>
</pre></div>
</div>
<p>where, the 192.168.1.232 is somewhat arbitrary - just make sure that the first 3 octets (192.168.1) are DIFFERENT from those of any other network adapters on your host machine. The next step is to configure your host’s network adapter. Open your computer’s “Network Connections” control panel note that your host could have lots of adapters. Sometimes it’s obvious - if you’re using a cable connection, it’s obviously NOT your wifi adapter. If you’re using a USB-Ethernet adapter (a super convenient option sometimes), plugging and unplugging the adapter, and seeing which disappears. Open the adapter’s configuration (right-click, “Properties”) and configure the IPV4 properties as shown in Figure 16 below. Make sure the last octet in the IP address is DIFFERENT from that set on the Raspberry Pi.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../../_images/static_ip_host.png"><img alt="../../../_images/static_ip_host.png" src="../../../_images/static_ip_host.png" style="width: 600px;" />
</a>
</figure>
<p><strong>Figure 16. Setting Up Static IP on Windows Host</strong></p>
<p>Finally… open a command prompt, and ping your Raspberry Pi as shown in Figure 17:</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../../_images/ping_rpi.png"><img alt="../../../_images/ping_rpi.png" src="../../../_images/ping_rpi.png" style="width: 600px;" />
</a>
</figure>
<p><strong>Figure 17. Pinging the Headless Pi</strong></p>
<p>If you get a reply, you’re all set! You can now log into the Raspberry Pi using PuTTY, VNC, and talk to attached IIO devices via IIO oscilloscope or libiio on the remote host.</p>
<p><strong>Leveraged Learning:</strong> This process (and any frustrations accompanied on the way) is the same for using any network connected embedded computer, test equipment, etc.</p>
</section>
<section id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Link to this heading">¶</a></h2>
<p>You’re now armed to start building interesting application circuits with the ADXL345, starting with a solid software foundation. Applications can either be connected to a host computer, or can run remotely on the Raspberry Pi itself. Hopefully you’re left with one of two feelings:</p>
<ol class="arabic simple">
<li><p>Device drivers look really complicated, thank goodness I can dive in as a user and do something useful without having to fully understand the details. (If this is the case, see if the devices you’re using in your present work are supported in ADI Kuiper Linux, and try to get them up and running.)</p></li>
<li><p>This is really interesting! I want to know more! (If this is the case, great! A good starting point would be <a class="reference external" href="/resources/tools-software/linux-build/generic/raspberrypi">Building for Raspberry PI</a>)</p></li>
</ol>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>pei·ow·tee : ‘p’ in pie; ‘a’ in about; ‘y’ yes; ‘o’ in code; ‘t’ in tie; ‘y’ in happy</p>
</aside>
</aside>
</section>
</section>


          </div>
              <div class="related">
                &nbsp;
    <a href="../wien_bridge_oscillator/index.html" title="Previous document (Alt+Shift+LeftArrow)" class="prev">Activity: The Wien Bridge Oscillator</a>
    <a href="../../../ltspice_examples/lvds_pair/index.html" title="Next document (Alt+Shift+RightArrow)" class="next">LTspice Example: LVDS pair</a>
              </div>
          
        </div>
      </div>
  </div>

  <div id="vertical-border"></div>

  <label id="cancel-area-show-toc" for="input-show-toc"></label>
  <label id="cancel-area-show-localtoc" for="input-show-localtoc"></label>
    <footer>
      &#169;2024, Analog Devices, Inc.
      
      |
      Made with <a href="https://www.sphinx-doc.org/">Sphinx</a>
      &amp; <a href="https://github.com/analogdevicesinc/doctools">Doctools</a>
      
    </footer>
  </body>
</html>